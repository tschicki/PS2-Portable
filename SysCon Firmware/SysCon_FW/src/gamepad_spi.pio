.program gamepad_spi

  set pins, 1    ; set DAT line high by default, this init would be triggered with every rising edge of ATT by resetting the state machine

.wrap_target
  set x, 7      ; 8 bits per frame
  pull block    ; pull byte from fifo into OSR; wait until there is a byte in the fifo

transceive:
  wait 0 pin 2  ; wait for clock to go low
  out PINS, 1   ; shift tx bit out from OSR
  wait 1 pin 2  ; wait for clock to go high
  in PINS, 1    ; shift rx bit into ISR
  jmp x--, transceive 

transceive_done:
  in NULL, 24   ; put the byte in a convenient place
  push          ; push recieved byte from the ISR into rx fifo
  irq wait 0    ; notify the system that the frame is finished
  .wrap     ; go back to start to handle next byte in transmission

% c-sdk {
#include "hardware/gpio.h"

static inline void pio_spi_init(PIO pio, uint sm, uint offset, uint pin_cmd, uint pin_clk, uint pin_dat) {
  // get default sm config
  pio_sm_config c = gamepad_spi_program_get_default_config(offset);

  // initialize gpio for use with PIO
  pio_gpio_init(pio, pin_clk);
  pio_gpio_init(pio, pin_cmd);
  pio_gpio_init(pio, pin_dat);

  // set rx and clock as inputs 
  //pio_sm_set_pindirs_with_mask(pio, sm, (1 << pin_cmd) | (1 << pin_clk), false);
  pio_sm_set_consecutive_pindirs(pio, sm, pin_cmd, 3, false);

  // set tx as output
  //pio_sm_set_pindirs_with_mask(pio, sm, (1 << pin_dat), true);
  pio_sm_set_consecutive_pindirs(pio, sm, pin_dat, 1, true);

  // set pins for use with IN and WAIT instructions
  sm_config_set_in_pins(&c, pin_cmd);

  // set pins for use with OUT instruction
  sm_config_set_out_pins(&c, pin_dat, 1);
  sm_config_set_set_pins (&c, pin_dat, 1);

  // shift behavior set as shift-to-right (LSB first), autopull disabled, threshold is 8
  sm_config_set_out_shift(&c, true, false, 8);
  sm_config_set_in_shift(&c, true, false, 8);

  pio_sm_init(pio, sm, offset, &c);
  pio_sm_set_enabled(pio, sm, true);
}

static inline uint8_t pio_spi_write_tx_fifo(PIO pio, uint sm, uint8_t byte) {
  // byte to transmit
  pio_sm_put(pio, sm, byte);
}

static inline uint8_t pio_spi_read_rx_fifo(PIO pio, uint sm) {
  // byte to transmit
  return pio_sm_get(pio, sm);
}

static inline void pio_spi_deinit(PIO pio, uint sm, uint pin_dat) {

  pio_sm_set_enabled(pio, sm, false);
  gpio_init(pin_dat);
  gpio_set_dir(pin_dat, GPIO_IN);

}


%}